# Система иерархии элементов HTML парсера

## Обзор

Система **строит иерархию элементов** из HTML шаблонов с динамическими выражениями, полученными от `splitter`. Алгоритм создает структурированную иерархию с поддержкой:

- HTML элементов с дочерними узлами
- Map-операций (циклы по коллекциям)
- Условных операторов (тернарные выражения)
- Текстовых узлов (статических и динамических)

## Архитектура

### Принцип работы

Алгоритм работает **в один проход** по токенам элементов, полученным от `splitter`. Основная задача - построить правильную иерархию элементов, **не выполняя парсинг выражений**.

### Входные данные

- `html: string` - сырой HTML-текст из `extractMainHtmlBlock`
- `elements: ElementToken[]` - токены элементов из `extractHtmlElements`

### Основные типы узлов

#### 1. NodeElement - HTML элементы

Содержит имя тега, исходный текст и дочерние элементы.

#### 2. NodeMap - Циклы по коллекциям

Содержит исходный текст map-выражения и дочерние элементы для повторения.

#### 3. NodeCondition - Условные операторы

Содержит исходный текст условия и две ветки: true и false.

#### 4. NodeText - Текстовые узлы

Содержит исходный текст (включая ${...} выражения).

## Алгоритм построения иерархии

### Основные принципы

1. **Один проход** - алгоритм проходит по элементам один раз
2. **Стек элементов** - отслеживает открытые теги для правильной вложенности
3. **Отложенное создание** - map/condition создаются при закрытии соответствующих тегов
4. **Универсальный scope** - единая логика для всех типов map

### Пошаговый алгоритм

#### Шаг 1: Обработка открывающих тегов

- Создаем NodeElement для каждого открывающего тега
- Анализируем подстроку перед элементом на наличие map/condition паттернов
- Ищем map паттерны: `core.list.map(({ title }) => html``
- Ищем condition паттерны: `context.flag ?`
- При обнаружении map запоминаем `startChildIndex` - текущее количество детей у родителя
- Добавляем элемент в иерархию к текущему родителю
- Добавляем открывающие теги в стек

#### Шаг 2: Обработка закрывающих тегов

- Находим соответствующий открывающий тег в стеке
- Создаем NodeMap если найдена информация о map
- Определяем scope map на основе `startChildIndex` - берем только детей, добавленных после обнаружения map
- Применяем универсальную логику: `parentElement.child = [...beforeChildren, mapNode]`
- Создаем NodeCondition если найдена информация об условии
- Удаляем закрытый тег из стека

#### Шаг 3: Обработка текстовых элементов

- Создаем NodeText для каждого текстового элемента
- Добавляем к текущему родителю в иерархии

### Универсальная логика определения scope для map

Алгоритм использует **универсальный подход** для определения scope любого map, независимо от имени массива:

#### Принцип работы

1. **При обнаружении map паттерна** - запоминаем индекс начала детей у родителя (`startChildIndex`)
2. **При закрытии тега** - оборачиваем в NodeMap только детей, добавленных с этого индекса
3. **Правильная вложенность** - вложенные map автоматически содержатся в scope родительского map

#### Преимущества универсального подхода

- **Не зависит от имен массивов** - работает для любых `core.list.map`, `nested.map`, `category.products.map`
- **Автоматическая вложенность** - вложенные map правильно содержатся в родительских
- **Правильный scope для соседствующих элементов** - корректно группирует элементы без общего HTML-родителя
- **Простота логики** - один алгоритм для всех случаев
- **Расширяемость** - легко добавлять новые типы map

## Примеры использования

### 1. Простой map

Создает NodeMap с дочерними элементами для повторения.

### 2. Map с соседствующими элементами

Алгоритм правильно группирует соседствующие элементы в рамках одного map, даже если они не имеют общего HTML-родителя:

```html
<ul>
  ${context.list.map((name) => html`
  <li>${name}</li>
  <br />
  `)}
</ul>
```

**Результат:** Оба элемента (`<li>` и `<br />`) становятся дочерними для одного `NodeMap`, хотя в HTML они находятся на одном уровне.

### 3. Map с вложенными объектами

Поддерживает сложные структуры данных с вложенными свойствами.

### 4. Вложенные map

Универсальный алгоритм правильно обрабатывает любые вложенные map:

- Вложенные map содержатся в scope родительского map
- Каждый map содержит только свои дочерние элементы
- Поддерживается любая глубина вложенности

### 5. Сложная вложенность map

Алгоритм корректно обрабатывает сложные случаи с множественными уровнями вложенности:

- `core.categories.map` → `category.products.map` → `product.variants.map`
- Каждый map содержит правильные дочерние элементы
- Сохраняется правильная иерархия на всех уровнях

### 6. Условия

Создает NodeCondition с двумя ветками: true и false.

### 7. Условие внутри map

Поддерживает вложенность условий внутри map операций.

## Преимущества нового алгоритма

### 1. Упрощение архитектуры

- **Один проход** вместо трех
- **Нет парсинга выражений** - только извлечение подстрок
- **Четкое разделение ответственности** - иерархия vs парсинг

### 2. Производительность

- **Линейная сложность** O(n) вместо O(3n)
- **Меньше операций** с DOM-подобными структурами
- **Эффективное использование памяти**

### 3. Надежность

- **Меньше точек отказа** - упрощенная логика
- **Предсказуемое поведение** - четкие правила
- **Легче тестировать** - изолированная функциональность

### 4. Расширяемость

- **Модульная архитектура** - парсинг вынесен в отдельные модули
- **Гибкие типы** - поддержка вложенных условий
- **Универсальная логика** - работает для любых имен массивов

## Ограничения

### 1. Упрощенный анализ

- **Нет парсинга выражений** - только извлечение подстрок
- **Ограниченная валидация** - полагается на корректность входных данных
- **Контекстные ограничения** - требует понимания структуры HTML

### 2. Зависимость от splitter

- **Строгая привязка** к формату токенов от splitter
- **Ограниченная гибкость** - не может работать с другими парсерами
- **Совместная эволюция** - изменения в splitter влияют на hierarchy

### 3. Универсальность scope

- **Работает для любых имен массивов** - не привязан к конкретным паттернам
- **Автоматическая вложенность** - правильно обрабатывает сложные случаи
- **Простота поддержки** - один алгоритм для всех случаев

## Покрытие функциональности

Алгоритм поддерживает все основные сценарии использования:

- **Простые map** - базовые циклы по коллекциям
- **Map с соседствующими элементами** - группировка элементов без общего HTML-родителя
- **Map с вложенными объектами** - сложные структуры данных
- **Вложенные map** - многоуровневые циклы
- **Сложная вложенность map** - множественные уровни вложенности
- **Map в условиях** - комбинация map и условных операторов
- **Условия** - тернарные операторы
- **Условие внутри map** - вложенность условий
- **Текстовые узлы** - статические и динамические тексты
- **HTML элементы** - теги, атрибуты, вложенность

## Будущие улучшения

### 1. Расширенная поддержка выражений

- **Модуль парсинга выражений** - отдельный компонент для анализа
- **Поддержка сложных выражений** - функции, методы, вычисления
- **Валидация выражений** - проверка корректности

### 2. Оптимизация производительности

- **Кэширование результатов** - для повторяющихся паттернов
- **Ленивые вычисления** - отложенная обработка сложных случаев
- **Параллельная обработка** - для больших документов

### 3. Расширенная типизация

- **Строгая типизация** - полная поддержка TypeScript
- **Валидация типов** - проверка корректности структур
- **Автодополнение** - поддержка IDE
