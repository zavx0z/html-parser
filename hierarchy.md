# Система иерархии элементов HTML парсера

## Обзор

Система **строит иерархию элементов** из HTML шаблонов с динамическими выражениями, полученными от `splitter`. Алгоритм создает структурированную иерархию с поддержкой:

- HTML элементов с дочерними узлами
- Map-операций (циклы по коллекциям)
- Условных операторов (тернарные выражения)
- Текстовых узлов (статических и динамических)

## Архитектура

### Принцип работы

Алгоритм работает **в один проход** по токенам элементов, полученным от `splitter`. Основная задача - построить правильную иерархию элементов, **не выполняя парсинг выражений**.

### Входные данные

- `html: string` - сырой HTML-текст из `extractMainHtmlBlock`
- `elements: ElementToken[]` - токены элементов из `extractHtmlElements`

### Основные типы узлов

#### 1. NodeElement - HTML элементы

Содержит имя тега, исходный текст и дочерние элементы.

#### 2. NodeMap - Циклы по коллекциям

Содержит исходный текст map-выражения и дочерние элементы для повторения.

#### 3. NodeCondition - Условные операторы

Содержит исходный текст условия и две ветки: true и false.

#### 4. NodeText - Текстовые узлы

Содержит исходный текст (включая ${...} выражения).

## Алгоритм построения иерархии

### Основные принципы

1. **Один проход** - алгоритм проходит по элементам один раз
2. **Стек элементов** - отслеживает открытые теги для правильной вложенности
3. **Отложенное создание** - map/condition создаются при закрытии соответствующих тегов
4. **Контекстный анализ** - разные стратегии для разных типов map

### Пошаговый алгоритм

#### Шаг 1: Обработка открывающих тегов

- Создаем NodeElement для каждого открывающего тега
- Анализируем подстроку перед элементом на наличие map/condition паттернов
- Ищем map паттерны: `core.list.map(({ title }) => html``
- Ищем condition паттерны: `context.flag ?`
- Добавляем элемент в иерархию к текущему родителю
- Добавляем открывающие теги в стек

#### Шаг 2: Обработка закрывающих тегов

- Находим соответствующий открывающий тег в стеке
- Создаем NodeMap если найдена информация о map
- Определяем какие элементы должны быть в map
- Применяем логику в зависимости от типа map (обычный или вложенный)
- Создаем NodeCondition если найдена информация об условии
- Удаляем закрытый тег из стека

#### Шаг 3: Обработка текстовых элементов

- Создаем NodeText для каждого текстового элемента
- Добавляем к текущему родителю в иерархии

### Логика для вложенных map

Алгоритм различает два контекста для `nested.map`:

#### Контекст 1: Структурированный HTML (с переносами строк)

**Стратегия:** Map обертывает только текстовый узел `${n}`, а не весь элемент `<em>`.

#### Контекст 2: Инлайн HTML

**Стратегия:** Map обертывает весь элемент `<em>`.

**Определение контекста:** Проверяем наличие текстовых узлов на том же уровне что и элементы.

## Примеры использования

### 1. Простой map

Создает NodeMap с дочерними элементами для повторения.

### 2. Map с вложенными объектами

Поддерживает сложные структуры данных с вложенными свойствами.

### 3. Вложенные map (Контекст 1)

Структурированный HTML - map обертывает только текстовые узлы.

### 4. Вложенные map (Контекст 2)

Инлайн HTML - map обертывает целые элементы.

### 5. Условия

Создает NodeCondition с двумя ветками: true и false.

### 6. Условие внутри map

Поддерживает вложенность условий внутри map операций.

## Преимущества нового алгоритма

### 1. Упрощение архитектуры

- **Один проход** вместо трех
- **Нет парсинга выражений** - только извлечение подстрок
- **Четкое разделение ответственности** - иерархия vs парсинг

### 2. Производительность

- **Линейная сложность** O(n) вместо O(3n)
- **Меньше операций** с DOM-подобными структурами
- **Эффективное использование памяти**

### 3. Надежность

- **Меньше точек отказа** - упрощенная логика
- **Предсказуемое поведение** - четкие правила
- **Легче тестировать** - изолированная функциональность

### 4. Расширяемость

- **Модульная архитектура** - парсинг вынесен в отдельные модули
- **Гибкие типы** - поддержка вложенных условий
- **Контекстная логика** - адаптация к разным сценариям

## Ограничения

### 1. Упрощенный анализ

- **Нет парсинга выражений** - только извлечение подстрок
- **Ограниченная валидация** - полагается на корректность входных данных
- **Контекстные ограничения** - требует понимания структуры HTML

### 2. Зависимость от splitter

- **Строгая привязка** к формату токенов от splitter
- **Ограниченная гибкость** - не может работать с другими парсерами
- **Совместная эволюция** - изменения в splitter влияют на hierarchy

## Будущие улучшения

### 1. Расширенная поддержка выражений

- **Модуль парсинга выражений** - отдельный компонент для анализа
- **Поддержка сложных выражений** - функции, методы, вычисления
- **Валидация выражений** - проверка корректности

### 2. Оптимизация производительности

- **Кэширование результатов** - для повторяющихся паттернов
- **Ленивые вычисления** - отложенная обработка сложных случаев
- **Параллельная обработка** - для больших документов

### 3. Расширенная типизация

- **Строгая типизация** - полная поддержка TypeScript
- **Валидация типов** - проверка корректности структур
- **Автодополнение** - поддержка IDE
