# Формат данных для обогащенной иерархии

## Обзор

Модуль `data` обогащает HTML иерархию информацией о путях к данным, выражениях и статических значениях.

## Типы узлов

### 1. Map узлы

Представляют итерации по массивам данных.

```typescript
{
  type: "map",
  data: string,  // Путь к массиву данных
  child: Node[]
}
```

**Логика определения путей:**

- **Абсолютные пути**: `core.list.map(...)` → `data: "/core/list"`
- **Относительные пути**: `category.products.map(...)` → `data: "[item]/products"` (в контексте родительского map)

**Примеры:**

```typescript
// core.list.map(({ title, nested }) => ...)
{
  type: "map",
  data: "/core/list",
  child: [...]
}

// nested.map((n) => ...) в контексте map
{
  type: "map",
  data: "[item]/nested",
  child: [...]
}
```

**Логика путей данных в контексте map:**

При обработке переменных внутри map контекста, система различает два типа параметров:

#### Простые параметры (один параметр)

Когда map имеет один простой параметр, переменная представляет сам элемент массива:

```typescript
// context.list.map((name) => html`<li>${name}</li>`)
// name - это сам элемент массива (строка)
{
  type: "text",
  data: "[item]"  // Сам элемент массива
}

// nested.map((n) => html`<em>${n}</em>`)
// n - это сам элемент массива (строка)
{
  type: "text",
  data: "[item]"  // Сам элемент массива
}
```

#### Деструктурированные свойства (несколько параметров)

Когда map использует деструктуризацию, переменные представляют свойства объекта:

```typescript
// core.list.map(({ title, nested }) => html`<li>${title}</li>`)
// title - это свойство объекта в массиве
{
  type: "text",
  data: "[item]/title"  // Свойство объекта
}

// nested - это свойство объекта в массиве
{
  type: "map",
  data: "[item]/nested"  // Свойство объекта
}
```

**Определение типа параметра:**

Система определяет тип параметра по количеству параметров в `mapParams`:

- `mapParams.length === 1` → простой параметр → `[item]`
- `mapParams.length > 1` → деструктуризация → `[item]/variable`

Это позволяет корректно обрабатывать как массивы примитивов, так и массивы объектов.

### 2. Condition узлы

Представляют условные выражения.

```typescript
{
  type: "cond",
  data: string | string[],  // Путь(и) к данным
  expr?: string,            // Выражение с индексами (если несколько переменных)
  true: Node,
  false: Node
}
```

**Логика определения:**

#### Простые условия (одна переменная)

```typescript
// "context.flag"
{
  type: "cond",
  data: "/context/flag",
  // expr отсутствует для простых условий
  true: {...},
  false: {...}
}
```

**Логика определения expr:**

Поле `expr` добавляется только если:

- **Сложное условие** (несколько переменных), ИЛИ
- **Есть операторы/методы** в выражении

**Операторы, требующие expr:**

- Математические: `%`, `+`, `-`, `*`, `/`
- Логические: `&&`, `||`
- Сравнения: `===`, `!==`, `==`, `!=`, `<`, `>`
- Скобки: `(`
- Методы: `.` (точки)

#### Сложные условия (несколько переменных)

```typescript
// "context.cond && context.cond2"
{
  type: "cond",
  data: ["/context/cond", "/context/cond2"],
  expr: "${0} && ${1}",
  true: {...},
  false: {...}
}

// "context.flag === context.cond2"
{
  type: "cond",
  data: ["/context/flag", "/context/cond2"],
  expr: "${0} === ${1}",
  true: {...},
  false: {...}
}

// "i % 2" в контексте map
{
  type: "cond",
  data: ["/i"],
  expr: "${0} % 2",
  true: {...},
  false: {...}
}
```

#### Условия с операторами (одна переменная)

```typescript
// "i % 2" в контексте map
{
  type: "cond",
  data: "[index]",
  expr: "${0} % 2",
  true: {...},
  false: {...}
}

// "context.items.length > 0"
{
  type: "cond",
  data: "/context/items",
  expr: "${0}.length > 0",
  true: {...},
  false: {...}
}

// "(context.flag)"
{
  type: "cond",
  data: "/context/flag",
  expr: "(${0})",
  true: {...},
  false: {...}
}
```

### 3. Text узлы

Представляют текстовые данные.

```typescript
{
  type: "text",
  data?: string | string[],  // Путь(и) к данным (если динамический)
  value?: string,            // Статическое значение (если статический)
  expr?: string              // Выражение с индексами (если смешанный)
}
```

**Логика определения:**

#### Статический текст

```typescript
// "static"
{
  type: "text",
  value: "static"
}
```

#### Только переменная

```typescript
// "${context.name}"
{
  type: "text",
  data: "/context/name"
}
```

#### Переменная с методом

```typescript
// "${context.name.toLowerCase()}"
{
  type: "text",
  data: "/context/name",
  expr: "${0}.toLowerCase()"
}
```

#### Переменная с текстом

```typescript
// "Hello, ${context.name}!"
{
  type: "text",
  data: "/context/name",
  expr: "Hello, ${0}!"
}
```

#### Переменная с пробельными символами

```typescript
// "${context.name} " (с пробелом)
{
  type: "text",
  data: "/context/name",
  expr: "${0} "
}

// "${context.name}\n" (с переносом строки)
{
  type: "text",
  data: "/context/name",
  expr: "${0}\n"
}
```

**Логика определения expr для текста:**

Поле `expr` добавляется если:

- **Несколько переменных** в тексте
- **Есть статический текст** (не только пробелы)
- **Есть пробельные символы** (пробелы, табуляция, переносы строк)

#### Несколько переменных

```typescript
// "Hello, ${context.family} ${context.name}!"
{
  type: "text",
  data: ["/context/family", "/context/name"],
  expr: "Hello, ${0} ${1}!"
}
```

#### В контексте map

```typescript
// Простой параметр: "${name}" в context.list.map((name) => ...)
{
  type: "text",
  data: "[item]"  // Сам элемент массива
}

// Деструктурированное свойство: "${title}" в map(({ title }) => ...)
{
  type: "text",
  data: "[item]/title"  // Свойство объекта
}

// Деструктурированное свойство с текстом: "${title} " в map(({ title }) => ...)
{
  type: "text",
  data: "[item]/title",
  expr: "${0} "
}
```

### 4. Element узлы

Обычные HTML элементы остаются без изменений.

```typescript
{
  tag: string,
  type: "el",
  child: Node[]
}
```

## Унификация выражений (expr)

Для упрощения обработки и кэширования все выражения с переменными унифицируются через систему индексов.

### Принцип работы

1. **Извлечение переменных**: Находим все переменные в выражении
2. **Сохранение путей**: Сохраняем пути к данным в массиве `data`
3. **Замена на индексы**: Заменяем переменные в выражении на `${0}`, `${1}`, etc.

### Примеры унификации

#### Условия

```typescript
// Исходное: "context.cond && context.cond2"
// Результат:
{
  data: ["/context/cond", "/context/cond2"],
  expr: "${0} && ${1}"
}

// Исходное: "i % 2" в контексте map((_, i) => ...)
// Результат:
{
  data: "[index]",
  expr: "${0} % 2"
}
```

#### Текст

```typescript
// Исходное: "Hello, ${context.family} ${context.name}!"
// Результат:
{
  data: ["/context/family", "/context/name"],
  expr: "Hello, ${0} ${1}!"
}

// Исходное: "${context.name.toLowerCase()}"
// Результат:
{
  data: "/context/name",
  expr: "${0}.toLowerCase()"
}
```

### Преимущества унификации

- **Кэширование**: Обезличенные выражения можно кэшировать независимо от конкретных данных
- **Упрощение рендеринга**: Рендеры работают с унифицированным форматом
- **Разделение данных и логики**: Четкое разделение между путями к данным и логикой выражения
- **Переиспользование**: Одинаковые выражения с разными данными используют один шаблон

## Правила относительности путей

### Абсолютные пути

Начинаются с `/core/` или `/context/`:

- `/core/list` - массив из core
- `/context/name` - свойство из context

### Относительные пути

Используют `[item]` и `[index]` для элементов массива:

- `[item]` - текущий элемент массива (для простых параметров)
- `[item]/title` - свойство title текущего элемента (для деструктурированных свойств)
- `[item]/nested` - свойство nested текущего элемента (для деструктурированных свойств)
- `[index]` - индекс текущего элемента в массиве (для второго и последующих параметров map)

### Контекст вложенности

Каждый map создает контекст для относительных путей:

#### Простые параметры (массивы примитивов)

- В контексте `context.list.map((name) => ...)`:

  - `${name}` → `[item]` (сам элемент массива)

- В контексте `nested.map((n) => ...)`:
  - `${n}` → `[item]` (сам элемент массива)

#### Параметры с индексом

- В контексте `context.list.map((_, i) => ...)`:

  - `${i}` → `[index]` (индекс элемента в массиве)

- В контексте `context.list.map((name, index) => ...)`:
  - `${name}` → `[item]` (сам элемент массива)
  - `${index}` → `[index]` (индекс элемента в массиве)

#### Деструктурированные свойства (массивы объектов)

- В контексте `core.list.map(({ title, nested }) => ...)`:
  - `${title}` → `[item]/title` (свойство объекта)
  - `${nested}` → `[item]/nested` (свойство объекта)

### Определение типа пути

Система автоматически определяет тип пути по позиции параметра в map:

- **Первый параметр** → элемент массива:
  - Один параметр → `[item]` (простой параметр)
  - Несколько параметров → `[item]/property` (деструктуризация)
- **Второй и последующие параметры** → `[index]` (индекс элемента)

## Использование

```typescript
import { enrichHierarchyWithData } from "./data"

// Обогащаем иерархию данными
const enrichedHierarchy = enrichHierarchyWithData(hierarchy)
```

## Форматирование выражений и текста

Система автоматически форматирует выражения и текст по стандартам HTML для улучшения читаемости и производительности.

### Форматирование тернарных выражений

Система удаляет лишние пробелы и переносы строк в тернарных выражениях, сохраняя при этом строковые литералы.

#### Функция `createUnifiedExpression`

```typescript
const createUnifiedExpression = (value: string, variables: string[]): string => {
  let expr = value
  variables.forEach((variable, index) => {
    expr = expr.replace(new RegExp(`\\$\\{${variable.replace(/\./g, "\\.")}\\}`, "g"), `\${${index}}`)
  })

  // Форматируем выражение: удаляем лишние пробелы и переносы строк, но сохраняем строковые литералы
  const stringLiterals: string[] = []
  let protectedExpr = expr
    .replace(/"[^"]*"/g, (match) => {
      stringLiterals.push(match)
      return `__STRING_${stringLiterals.length - 1}__`
    })
    .replace(/'[^']*'/g, (match) => {
      stringLiterals.push(match)
      return `__STRING_${stringLiterals.length - 1}__`
    })

  // Удаляем лишние пробелы и переносы строк в выражениях
  protectedExpr = protectedExpr.replace(/\s+/g, " ").trim()

  // Восстанавливаем строковые литералы
  stringLiterals.forEach((literal, index) => {
    protectedExpr = protectedExpr.replace(`__STRING_${index}__`, literal)
  })

  return protectedExpr
}
```

#### Примеры форматирования выражений

**До форматирования:**

```typescript
// Многострочное выражение с лишними пробелами
;`${context.flag ? "active" : "inactive"}`
```

**После форматирования:**

```typescript
// Чистое однострочное выражение
;`${0} ? "active" : "inactive"`
```

**Сохранение строковых литералов:**

```typescript
// Сложное выражение с длинными строками
;`${0} ? "This is a very long text that should be formatted properly" : "Short text"`
```

### Форматирование текста по стандартам HTML

Система применяет стандартные правила HTML для схлопывания пробельных символов в тексте.

#### Функция `formatTextByHtmlStandards`

```typescript
const formatTextByHtmlStandards = (text: string): string => {
  // Схлопываем последовательные пробельные символы в один пробел
  // и удаляем пробелы в начале и конце
  return text.replace(/\s+/g, " ").trim()
}
```

#### Функция `formatStaticText`

```typescript
const formatStaticText = (text: string): string => {
  // Если текст содержит только пробельные символы - удаляем их полностью
  if (text.trim().length === 0) {
    return ""
  }

  // Если текст содержит не-пробельные символы - форматируем по стандартам HTML
  // НО только если это многострочный текст или содержит много пробелов
  if (text.includes("\n") || text.includes("\t") || /\s{3,}/.test(text)) {
    return formatTextByHtmlStandards(text)
  }

  // Иначе оставляем как есть
  return text
}
```

#### Правила форматирования текста

**Схлопывание пробельных символов:**

- Последовательные пробелы → один пробел
- Переносы строк → один пробел
- Табуляции → один пробел
- Комбинации → один пробел

**Удаление пробелов:**

- Пробелы в начале и конце текстового содержимого удаляются

**Сохранение важных пробелов:**

- Пробелы между переменными в выражениях сохраняются
- Строковые литералы остаются нетронутыми

#### Примеры форматирования текста

**До форматирования:**

```html
<p>Hello World</p>
```

**После форматирования:**

```html
<p>Hello World</p>
```

**Сохранение важных пробелов:**

```html
<!-- Пробелы между переменными сохраняются -->
<p>Hello, ${name} ${surname}!</p>
<!-- Результат: "Hello, ${0} ${1}!" -->
```

**Многострочный текст:**

```html
<div>Welcome to our site!</div>
<!-- Результат: "Welcome to our site!" -->
```

### Интеграция с парсингом

Форматирование интегрировано в процесс парсинга и применяется автоматически:

1. **В `parseTextData`** - для статического текста
2. **В `splitTextIntoParts`** - для статических частей смешанного текста
3. **В `createUnifiedExpression`** - для тернарных выражений
4. **В `parseTemplateLiteral`** - для сложных выражений

### Преимущества форматирования

- **Читаемость**: Выражения становятся более компактными и читаемыми
- **Производительность**: Меньше пробельных символов для обработки
- **Стандартность**: Соответствие стандартам HTML
- **Совместимость**: Сохранение важных пробелов и строковых литералов
