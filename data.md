# Система обогащения данных

Система обогащения данных предназначена для анализа HTML иерархии и извлечения метаданных о путях к данным, выражениях и статических значениях. Это позволяет эффективно рендерить динамический контент с минимальными пересчетами.

## Основные возможности

- Автоматическое определение путей к данным в map операциях
- Унификация выражений для кэширования
- Поддержка вложенных контекстов
- Обработка условных выражений
- Извлечение путей из атрибутов и событий
- Поддержка деструктуризации параметров

## Архитектура системы

### Ключевые компоненты

1. **DataParserContext** - контекст парсера с информацией о текущем состоянии
2. **MapContext** - информация о конкретном map контексте
3. **resolveDataPath** - универсальная функция разрешения путей
4. **findVariableInMapStack** - поиск переменных в стеке map контекстов
5. **parseEventExpression** - специальная функция для парсинга событий

### Система контекстов

Система создает иерархию контекстов для каждого уровня вложенности map функций:

```typescript
type DataParserContext = {
  currentPath?: string // Текущий путь к данным
  pathStack: string[] // Стек путей
  mapParams?: string[] // Параметры текущего map
  level: number // Уровень вложенности
  mapContextStack?: MapContext[] // Стек всех map контекстов
}
```

## Извлечение путей в атрибутах

### Основные принципы

Система автоматически извлекает пути к данным из атрибутов HTML элементов, учитывая контекст вложенности map функций. Это позволяет правильно разрешать относительные пути между разными уровнями итерации.

### Поддерживаемые типы атрибутов

1. **Статические атрибуты** - обычные строковые значения
2. **Динамические атрибуты** - с template literals `${variable}`
3. **Условные атрибуты** - с тернарными операторами
4. **Булевые атрибуты** - с логическими операторами `&&`
5. **Событийные атрибуты** - с функциями обработчиков

### Примеры работы

```html
<!-- Простой атрибут -->
<div class="item-${item.type}">${item.name}</div>

<!-- Условный атрибут -->
<div class="${item.active ? 'active' : 'inactive'}">${item.name}</div>

<!-- Булевый атрибут -->
<button ${item.disabled && "disabled"}>Click</button>
```

### Алгоритм извлечения путей

1. **Парсинг атрибутов** - функция `parseAttributesImproved` анализирует HTML тег
2. **Определение типа значения** - проверяется наличие template literals
3. **Извлечение переменных** - извлекаются все переменные из выражения
4. **Разрешение путей** - используется `resolveDataPath` с учетом контекста
5. **Унификация выражений** - создается выражение с индексами для кэширования

## Извлечение путей в событиях

### Специальная обработка событий

События требуют особого подхода, так как они содержат сложные выражения с функциями. Система использует специальную функцию `parseEventExpression` для корректной обработки событийных атрибутов.

### Поддерживаемые форматы событий

1. **Простые события** - `onclick=${core.onClick}`
2. **События с параметрами** - `onclick=${() => core.onClick()}`
3. **События с аргументами** - `onclick=${(e) => core.onClick(e)}`
4. **События в контексте map** - `onclick=${() => item.handleClick(item.id)}`

### Алгоритм обработки событий

1. **Определение событийного выражения** - проверка наличия `=>`
2. **Извлечение переменных** - поиск всех переменных в формате `identifier.identifier`
3. **Фильтрация** - исключение строковых литералов и коротких идентификаторов
4. **Разрешение путей** - использование `resolveDataPath` с контекстом
5. **Создание выражения** - замена переменных на индексы `${0}`, `${1}`, etc.

### Примеры работы с событиями

```html
<!-- Простое событие -->
<button onclick=${core.onClick}>Click</button>

<!-- Событие с параметрами -->
<button onclick=${(e) => core.handleClick(e, item.id)}>Click</button>

<!-- Событие в map контексте -->
${items.map((item) => html`
  <button onclick=${() => item.handleClick(item.id)}>${item.name}</button>
`)}
```

### Вложенные события

Система корректно обрабатывает события в сложных вложенных структурах:

```html
${companies.map((company) => html`
  <section onclick=${() => company.handleClick(company.id)}>
    ${company.departments.map((dept) => html`
      <article onclick=${() => dept.handleClick(company.id, dept.id)}>
        ${dept.teams.map((team) => html`
          <div onclick=${() => team.handleClick(company.id, dept.id, team.id)}>
            ${team.members.map((member) => html`
              <p onclick=${() => member.handleClick(company.id, dept.id, team.id, member.id)}>
                ${member.name}
              </p>
            `)}
          </div>
        `)}
      </article>
    `)}
  </section>
`)}
```

**Результат обработки:**

- `company.handleClick` → `[item]/handleClick`
- `dept.handleClick` → `[item]/handleClick` (в контексте dept)
- `company.id` в контексте dept → `../[item]/id`
- `team.handleClick` → `[item]/handleClick` (в контексте team)
- `company.id` в контексте team → `../../[item]/id`

## Вложенные контексты

### Иерархия контекстов

Система создает иерархию контекстов для каждого уровня вложенности map функций. Каждый контекст содержит информацию о параметрах и уровне вложенности.

### Автоматическое определение уровня вложенности

- Правильное разрешение путей между разными уровнями
- Поддержка произвольной глубины вложенности

## Обработка параметров map функций

### Простые параметры

Когда map функция принимает один параметр, система интерпретирует его как сам элемент массива. Это подходит для массивов примитивов (строк, чисел).

### Деструктурированные параметры

При использовании деструктуризации система автоматически определяет свойства объектов и создает соответствующие пути к данным. Это позволяет работать с массивами объектов.

### Параметры с индексами

Система поддерживает дополнительные параметры для доступа к индексам элементов. Второй и последующие параметры автоматически интерпретируются как индексы.

### Универсальность путей

Ключевая особенность системы - универсальность путей к данным. Независимо от способа доступа к данным (деструктуризация или доступ по ключу), система генерирует одинаковые пути, обеспечивая консистентность.

## Вложенные контексты

### Иерархия контекстов

Система создает иерархию контекстов для каждого уровня вложенности map функций. Каждый контекст содержит информацию о параметрах и уровне вложенности.

### Автоматическое создание контекстов

При парсинге map выражений автоматически создаются новые контексты:

```typescript
const newContext: DataParserContext = {
  ...context,
  currentPath: `[item]/${relativePath}`,
  pathStack: [...context.pathStack, `[item]/${relativePath}`],
  mapParams: params,
  level: context.level + 1,
  mapContextStack: [...(context.mapContextStack || []), newMapContext],
}
```

### Примеры разрешения путей

```typescript
// В контексте: companies.map((company) => departments.map((dept) => teams.map((team) => members.map((member) => ...)))

// Для переменной company.id в самом глубоком уровне:
resolveDataPath("company.id", context) // Возвращает: "../../../[item]/id"

// Для переменной dept.id в среднем уровне:
resolveDataPath("dept.id", context) // Возвращает: "../../[item]/id"

// Для переменной team.id в ближнем уровне:
resolveDataPath("team.id", context) // Возвращает: "../[item]/id"

// Для переменной member.id в текущем уровне:
resolveDataPath("member.id", context) // Возвращает: "[item]/id"
```

## Унификация выражений

### Создание унифицированных выражений

Система создает унифицированные выражения с индексами для эффективного кэширования:

```typescript
// Исходное выражение: class="${company.active && dept.active ? 'active' : 'inactive'}"
// Результат: {
//   data: ["../[item]/active", "[item]/active"],
//   expr: "${0} && ${1} ? 'active' : 'inactive'"
// }
```

### Форматирование выражений

Функция `createUnifiedExpression` выполняет:

1. Замену переменных на индексы
2. Удаление избыточных пробелов и переносов строк
3. Защиту строковых литералов от форматирования

## Преимущества системы

### 1. Точность разрешения путей

Система обеспечивает точное разрешение путей к данным независимо от глубины вложенности map функций.

### 2. Универсальность

Одинаковая логика работает для всех типов данных: атрибутов, событий, текста, условий.

### 3. Производительность

Унифицированные выражения позволяют эффективно кэшировать результаты вычислений.

### 4. Расширяемость

Архитектура позволяет легко добавлять новые типы обработки данных.
